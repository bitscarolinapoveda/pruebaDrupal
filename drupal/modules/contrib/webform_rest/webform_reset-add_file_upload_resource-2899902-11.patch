diff --git a/README.txt b/README.txt
index 489a2a9..3eb4e82 100644
--- a/README.txt
+++ b/README.txt
@@ -61,3 +61,33 @@ Retrieve Webform Submission
 ---------------------------
 
 GET /webform_rest/{webform_id}/submission/{sid}?_format=json
+
+Upload Files to a Webform
+---------------------------
+
+1. Enable the File module provided by Drupal
+2. Enable REST resource "Webform File Upload"
+3. Configure a file field for your Webform
+4. Submit a file:
+
+    POST /webform_rest/{webform_id}/upload/{field_name}?_format=json HTTP/1.1
+    Content-Type: application/octet-stream
+    Content-Disposition: file; filename="filename.pdf"
+
+    [... binary file data ...]
+
+5. The response to the previous POST will contain data about the uploaded file including a file id:
+    {
+      "fid": [{"value": 345345}]
+    }
+
+6. Your application should then post the webform submission as described in the "Submit Webform" section above, passing
+the fid value you received as the value for your webform's file field:
+    {
+      "webform_id": "my_webform",
+      "checkboxes_field": [
+        "Option 3",
+        "Option 5"
+       ],
+       "file_field": "345345",
+    }
diff --git a/src/Plugin/rest/resource/WebformFileUploadResource.php b/src/Plugin/rest/resource/WebformFileUploadResource.php
new file mode 100644
index 0000000..819d03a
--- /dev/null
+++ b/src/Plugin/rest/resource/WebformFileUploadResource.php
@@ -0,0 +1,196 @@
+<?php
+
+namespace Drupal\webform_rest\Plugin\rest\resource;
+
+use Drupal\Component\Utility\Bytes;
+use Drupal\file\Entity\File;
+use Drupal\file\Plugin\rest\resource\FileUploadResource;
+use Drupal\webform\Entity\Webform;
+use Drupal\webform\Entity\WebformSubmission;
+use Drupal\webform\WebformSubmissionForm;
+use Symfony\Component\HttpFoundation\Request;
+use Symfony\Component\HttpKernel\Exception\HttpException;
+use Drupal\rest\ModifiedResourceResponse;
+use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException;
+use Symfony\Component\HttpKernel\Exception\BadRequestHttpException;
+
+/**
+ * Creates a resource for webform file uploads.
+ *
+ * @RestResource(
+ *   id = "webform_rest_file_upload",
+ *   label = @Translation("Webform File Upload"),
+ *   serialization_class = "Drupal\file\Entity\File",
+ *   uri_paths = {
+ *     "https://www.drupal.org/link-relations/create" = "/webform_rest/{webform_id}/upload/{field_name}"
+ *   }
+ * )
+ */
+class WebformFileUploadResource extends FileUploadResource {
+
+  /**
+   * Creates a file from an endpoint.
+   *
+   * @param \Symfony\Component\HttpFoundation\Request $request
+   *   The current request.
+   * @param string $webform_id
+   *   The webform ID.
+   * @param string $field_name
+   *   The field name.
+   * @param string $placeholder
+   *   An unused placeholder to maintain compatibility with the parent method.
+   *
+   * @return \Drupal\rest\ResourceResponse
+   *   The HTTP response object.
+   *
+   * @throws \Symfony\Component\HttpKernel\Exception\HttpException
+   *   Throws HttpException in case of error.
+   */
+  public function post(Request $request, $webform_id, $field_name, $placeholder = '') {
+
+    // Check for a valid webform.
+    $webform = Webform::load($webform_id);
+    if (!$webform) {
+      throw new BadRequestHttpException('Invalid webform_id value.');
+    }
+
+    // Check webform is open.
+    $is_open = WebformSubmissionForm::isOpen($webform);
+
+    if ($is_open === TRUE) {
+
+      $filename = $this->validateAndParseContentDispositionHeader($request);
+
+      $element = $webform->getElement($field_name);
+
+      $webform_submission = WebformSubmission::create([
+        'webform_id' => $webform->id(),
+      ]);
+
+      // Prepare upload location and validators for the element
+      $element_plugin = $this->getElementPlugin($element);
+      $element_plugin->prepare($element, $webform_submission);
+
+      $destination = $element['#upload_location'];
+
+      // Check the destination file path is writable.
+      if (!file_prepare_directory($destination, FILE_CREATE_DIRECTORY)) {
+        throw new HttpException(500, 'Destination file path is not writable');
+      }
+
+      $validators = $this->getElementValidators($element);
+
+      $prepared_filename = $this->prepareFilename($filename, $validators);
+
+      // Create the file.
+      if (substr($destination, -1) === '/') {
+        $file_uri = "{$destination}{$prepared_filename}";
+      }
+      else {
+        $file_uri = "{$destination}/{$prepared_filename}";
+      }
+
+      $temp_file_path = $this->streamUploadData();
+
+      // This will take care of altering $file_uri if a file already exists.
+      file_unmanaged_prepare($temp_file_path, $file_uri);
+
+      // Lock based on the prepared file URI.
+      $lock_id = $this->generateLockIdFromFileUri($file_uri);
+
+      if (!$this->lock->acquire($lock_id)) {
+        throw new HttpException(503, sprintf('File "%s" is already locked for writing'), NULL, ['Retry-After' => 1]);
+      }
+
+      // Begin building file entity.
+      $file = File::create([]);
+      $file->setOwnerId($this->currentUser->id());
+      $file->setFilename($prepared_filename);
+      $file->setMimeType($this->mimeTypeGuesser->guess($prepared_filename));
+      $file->setFileUri($file_uri);
+      // Set the size. This is done in File::preSave() but we validate the file
+      // before it is saved.
+      $file->setSize(@filesize($temp_file_path));
+
+      // Validate the file entity against entity-level validation and field-level
+      // validators.
+      $this->validate($file, $validators);
+
+      // Move the file to the correct location after validation. Use
+      // FILE_EXISTS_ERROR as the file location has already been determined above
+      // in file_unmanaged_prepare().
+      if (!file_unmanaged_move($temp_file_path, $file_uri, FILE_EXISTS_ERROR)) {
+        throw new HttpException(500, 'Temporary file could not be moved to file location');
+      }
+
+      $file->save();
+
+      $this->lock->release($lock_id);
+
+      // 201 Created responses return the newly created entity in the response
+      // body. These responses are not cacheable, so we add no cacheability
+      // metadata here.
+      return new ModifiedResourceResponse($file, 201);
+
+
+    }
+    else {
+      throw new AccessDeniedHttpException('This webform is closed, or too many submissions have been made.');
+    }
+  }
+
+  /**
+   * Retrieves the upload validators for an element.
+   *
+   * This is copied from \Drupal\file\Plugin\Field\FieldType\FileItem as there
+   * is no entity instance available here that a FileItem would exist for.
+   *
+   * @param array $element
+   *   The element for which to get validators.
+   *
+   * @return array
+   *   An array suitable for passing to file_save_upload() or the file field
+   *   element's '#upload_validators' property.
+   */
+  protected function getElementValidators(array $element) {
+    $validators = [
+      // Add in our check of the file name length.
+      'file_validate_name_length' => [],
+    ];
+
+    // Cap the upload size according to the PHP limit.
+    $max_filesize = Bytes::toInt(file_upload_max_size());
+    if (!empty($element["#max_filesize"])) {
+      $max_filesize = min($max_filesize, Bytes::toInt($element['#max_filesize'] * 1024 * 1024));
+    }
+
+    // There is always a file size limit due to the PHP server limit.
+    $validators['file_validate_size'] = [$max_filesize];
+
+    // Add the extension check if necessary.
+    if (!empty($element['#file_extensions'])) {
+      $validators['file_validate_extensions'] = [$element['#file_extensions']];
+    }
+
+    return $validators;
+  }
+
+  /**
+   * Loads the webform element plugin for the provided element.
+   *
+   * @param array $element
+   *   The element for which to get the plugin.
+   *
+   * @return \Drupal\Core\Render\Element\ElementInterface
+   * @throws \Drupal\Component\Plugin\Exception\PluginException
+   */
+  protected function getElementPlugin(array $element) {
+    /** @var \Drupal\Core\Render\ElementInfoManager $plugin_manager */
+    $plugin_manager = \Drupal::service('plugin.manager.webform.element');
+    $plugin_definition = $plugin_manager->getDefinition($element['#type']);
+
+    $element_plugin = $plugin_manager->createInstance($element['#type'], $plugin_definition);
+
+    return $element_plugin;
+  }
+}
diff --git a/src/ProxyClass/WebformRestUninstallValidator.php b/src/ProxyClass/WebformRestUninstallValidator.php
new file mode 100644
index 0000000..ffd5060
--- /dev/null
+++ b/src/ProxyClass/WebformRestUninstallValidator.php
@@ -0,0 +1,80 @@
+<?php
+// @codingStandardsIgnoreFile
+
+/**
+ * This file was generated via php core/scripts/generate-proxy-class.php 'Drupal\webform_rest\WebformRestUninstallValidator' "modules/contrib/webform_rest/src".
+ */
+
+namespace Drupal\webform_rest\ProxyClass {
+
+    /**
+     * Provides a proxy class for \Drupal\webform_rest\WebformRestUninstallValidator.
+     *
+     * @see \Drupal\Component\ProxyBuilder
+     */
+    class WebformRestUninstallValidator implements \Drupal\Core\Extension\ModuleUninstallValidatorInterface
+    {
+
+        use \Drupal\Core\DependencyInjection\DependencySerializationTrait;
+
+        /**
+         * The id of the original proxied service.
+         *
+         * @var string
+         */
+        protected $drupalProxyOriginalServiceId;
+
+        /**
+         * The real proxied service, after it was lazy loaded.
+         *
+         * @var \Drupal\webform_rest\WebformRestUninstallValidator
+         */
+        protected $service;
+
+        /**
+         * The service container.
+         *
+         * @var \Symfony\Component\DependencyInjection\ContainerInterface
+         */
+        protected $container;
+
+        /**
+         * Constructs a ProxyClass Drupal proxy object.
+         *
+         * @param \Symfony\Component\DependencyInjection\ContainerInterface $container
+         *   The container.
+         * @param string $drupal_proxy_original_service_id
+         *   The service ID of the original service.
+         */
+        public function __construct(\Symfony\Component\DependencyInjection\ContainerInterface $container, $drupal_proxy_original_service_id)
+        {
+            $this->container = $container;
+            $this->drupalProxyOriginalServiceId = $drupal_proxy_original_service_id;
+        }
+
+        /**
+         * Lazy loads the real service from the container.
+         *
+         * @return object
+         *   Returns the constructed real service.
+         */
+        protected function lazyLoadItself()
+        {
+            if (!isset($this->service)) {
+                $this->service = $this->container->get($this->drupalProxyOriginalServiceId);
+            }
+
+            return $this->service;
+        }
+
+        /**
+         * {@inheritdoc}
+         */
+        public function validate($module)
+        {
+            return $this->lazyLoadItself()->validate($module);
+        }
+
+    }
+
+}
diff --git a/src/WebformRestUninstallValidator.php b/src/WebformRestUninstallValidator.php
new file mode 100644
index 0000000..7efbd82
--- /dev/null
+++ b/src/WebformRestUninstallValidator.php
@@ -0,0 +1,52 @@
+<?php
+
+namespace Drupal\webform_rest;
+
+use Drupal\Core\Config\ConfigFactoryInterface;
+use Drupal\Core\Extension\ModuleUninstallValidatorInterface;
+use Drupal\Core\StringTranslation\StringTranslationTrait;
+
+/**
+ * Prevents uninstallation of Webform REST module dependencies.
+ */
+class WebformRestUninstallValidator implements ModuleUninstallValidatorInterface {
+
+  use StringTranslationTrait;
+
+  /**
+   * The filter entity storage.
+   *
+   * @var \Drupal\Core\Config\Entity\ConfigEntityStorageInterface
+   */
+  protected $config_factory;
+
+  /**
+   * Constructs a new WebformRestUninstallValidator.
+   *
+   * @param \Drupal\Core\Config\ConfigFactoryInterface $config_factory
+   *   The config factory.
+   */
+  public function __construct(ConfigFactoryInterface $config_factory) {
+    $this->config_factory = $config_factory;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function validate($module) {
+    $reasons = [];
+
+    // Prevent uninstall of File module if the file upload resource is in use.
+    if ($module == 'file') {
+      $config = $this->config_factory->getEditable('rest.resource.webform_rest_file_upload');
+
+      $upload_resource_enabled = $config->get('status');
+
+      if ($upload_resource_enabled) {
+        $reasons[] = $this->t('Required by the following REST resource plugin: Webform File Upload');
+      }
+    }
+    return $reasons;
+  }
+
+}
diff --git a/webform_rest.module b/webform_rest.module
new file mode 100644
index 0000000..325727c
--- /dev/null
+++ b/webform_rest.module
@@ -0,0 +1,11 @@
+<?php
+
+/**
+ * Implements hook_rest_resource_alter().
+ */
+function webform_rest_rest_resource_alter(&$definitions) {
+  // Don't load the file upload resource unless the File module is enabled.
+  if (!\Drupal::moduleHandler()->moduleExists('file')) {
+    unset($definitions['webform_rest_file_upload']);
+  }
+}
diff --git a/webform_rest.services.yml b/webform_rest.services.yml
new file mode 100644
index 0000000..f61a773
--- /dev/null
+++ b/webform_rest.services.yml
@@ -0,0 +1,7 @@
+services:
+  webform_rest.uninstall_validator:
+    class: Drupal\webform_rest\WebformRestUninstallValidator
+    tags:
+      - { name: module_install.uninstall_validator }
+    arguments: ['@config.factory']
+    lazy: true
